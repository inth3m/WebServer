[TOC]

# 实现

## 并发模型

&nbsp;&nbsp;&nbsp;&nbsp;程序使用Reactor模型，并使用多线程提高并发度。为避免线程频繁创建和销毁带来的开销，使用线程池，在程序的开始创建固定数量的线程。使用epoll作为IO多路复用的实现方式。

### Reactor模式

事件循环loop->封装EPOLL_WAIT的poll->返回事件集handles->对每个handle执行事件handleEvent->handleEvent通过回调函数执行

![Screenshot_20190215_143320.png](https://i.loli.net/2019/02/15/5c665d74782dc.png)
![Screenshot_20190215_143720.png](https://i.loli.net/2019/02/15/5c665e210f01f.png)

MainReactor只有一个，负责响应client的连接请求，并建立连接，它使用一个NIO Selector。在建立连接后用Round Robin的方式分配给某个SubReactor,因为涉及到跨线程任务分配，需要加锁，这里的锁由某个特定线程中的loop创建，只会被该线程和主线程竞争。

SubReactor可以有一个或者多个，每个subReactor都会在一个独立线程中运行，并且维护一个独立的NIO Selector。


### 定时器

Timer里有两个数据结构：unordered_map和priority_queue，优先队列存放着TimerNode节点，只要节点的时间到了，或者该节点对应的channel事件关闭了那么该节点就可以删除，同时unorder_map是fd映射TimerNode节点，此TimerNode节点为fd对应的真正的节点，如果priority_queue删除的节点对应的不是unorder_map映射的节点，则证明当前的priority_queue里的节点并非真正的节点，故把堆顶的节点删除后要把unordered_map节点放进堆里。


## 内存池

&nbsp;&nbsp;&nbsp;&nbsp;结合STL的内存实现. 内存池维护了一个free_list,每一块都是8的倍数,从8开始,根据需要找不同的块,当块内存不足时通过malloc申请一块大内存

*图片来自STL源码剖析*

![Screenshot_20190215_142508.png](https://i.loli.net/2019/02/15/5c665b4580e6c.png)

![Screenshot_20190215_140027.png](https://i.loli.net/2019/02/15/5c6655741895f.png)
